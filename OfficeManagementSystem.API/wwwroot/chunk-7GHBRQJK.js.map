{"version":3,"sources":["node_modules/ng-apexcharts/fesm2022/ng-apexcharts.mjs","node_modules/@angular/core/fesm2022/rxjs-interop.mjs","node_modules/ngx-echarts/fesm2022/ngx-echarts.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { input, output, signal, viewChild, inject, NgZone, PLATFORM_ID, ChangeDetectionStrategy, Component, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { asapScheduler } from 'rxjs';\nconst _c0 = [\"chart\"];\nclass ChartComponent {\n  constructor() {\n    this.chart = input();\n    this.annotations = input();\n    this.colors = input();\n    this.dataLabels = input();\n    this.series = input();\n    this.stroke = input();\n    this.labels = input();\n    this.legend = input();\n    this.markers = input();\n    this.noData = input();\n    this.parsing = input();\n    this.fill = input();\n    this.tooltip = input();\n    this.plotOptions = input();\n    this.responsive = input();\n    this.xaxis = input();\n    this.yaxis = input();\n    this.forecastDataPoints = input();\n    this.grid = input();\n    this.states = input();\n    this.title = input();\n    this.subtitle = input();\n    this.theme = input();\n    this.autoUpdateSeries = input(true);\n    this.chartReady = output();\n    // If consumers need to capture the `chartInstance` for use, consumers\n    // can access the component instance through `viewChild` and use `computed`\n    // or `effect` on `component.chartInstance()` to monitor its changes and\n    // recompute effects or computations whenever `chartInstance` is updated.\n    this.chartInstance = signal(null);\n    this.chartElement = viewChild.required(\"chart\");\n    this.ngZone = inject(NgZone);\n    this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n  }\n  ngOnChanges(changes) {\n    if (!this.isBrowser) return;\n    this.ngZone.runOutsideAngular(() => {\n      asapScheduler.schedule(() => this.hydrate(changes));\n    });\n  }\n  ngOnDestroy() {\n    this.destroy();\n  }\n  hydrate(changes) {\n    const shouldUpdateSeries = this.autoUpdateSeries() && Object.keys(changes).filter(c => c !== \"series\").length === 0;\n    if (shouldUpdateSeries) {\n      this.updateSeries(this.series(), true);\n      return;\n    }\n    this.createElement();\n  }\n  async createElement() {\n    const {\n      default: ApexCharts\n    } = await import('apexcharts');\n    window.ApexCharts ||= ApexCharts;\n    const options = {};\n    const properties = [\"annotations\", \"chart\", \"colors\", \"dataLabels\", \"series\", \"stroke\", \"labels\", \"legend\", \"fill\", \"tooltip\", \"plotOptions\", \"responsive\", \"markers\", \"noData\", \"parsing\", \"xaxis\", \"yaxis\", \"forecastDataPoints\", \"grid\", \"states\", \"title\", \"subtitle\", \"theme\"];\n    properties.forEach(property => {\n      const value = this[property]();\n      if (value) {\n        options[property] = value;\n      }\n    });\n    this.destroy();\n    const chartInstance = this.ngZone.runOutsideAngular(() => new ApexCharts(this.chartElement().nativeElement, options));\n    this.chartInstance.set(chartInstance);\n    this.render();\n    this.chartReady.emit({\n      chartObj: chartInstance\n    });\n  }\n  render() {\n    return this.ngZone.runOutsideAngular(() => this.chartInstance()?.render());\n  }\n  updateOptions(options, redrawPaths, animate, updateSyncedCharts) {\n    return this.ngZone.runOutsideAngular(() => this.chartInstance()?.updateOptions(options, redrawPaths, animate, updateSyncedCharts));\n  }\n  updateSeries(newSeries, animate) {\n    return this.ngZone.runOutsideAngular(() => this.chartInstance()?.updateSeries(newSeries, animate));\n  }\n  appendSeries(newSeries, animate) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.appendSeries(newSeries, animate));\n  }\n  appendData(newData) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.appendData(newData));\n  }\n  highlightSeries(seriesName) {\n    return this.ngZone.runOutsideAngular(() => this.chartInstance()?.highlightSeries(seriesName));\n  }\n  toggleSeries(seriesName) {\n    return this.ngZone.runOutsideAngular(() => this.chartInstance()?.toggleSeries(seriesName));\n  }\n  showSeries(seriesName) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.showSeries(seriesName));\n  }\n  hideSeries(seriesName) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.hideSeries(seriesName));\n  }\n  resetSeries() {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.resetSeries());\n  }\n  zoomX(min, max) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.zoomX(min, max));\n  }\n  toggleDataPointSelection(seriesIndex, dataPointIndex) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.toggleDataPointSelection(seriesIndex, dataPointIndex));\n  }\n  destroy() {\n    this.chartInstance()?.destroy();\n    this.chartInstance.set(null);\n  }\n  setLocale(localeName) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.setLocale(localeName));\n  }\n  paper() {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.paper());\n  }\n  addXaxisAnnotation(options, pushToMemory, context) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.addXaxisAnnotation(options, pushToMemory, context));\n  }\n  addYaxisAnnotation(options, pushToMemory, context) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.addYaxisAnnotation(options, pushToMemory, context));\n  }\n  addPointAnnotation(options, pushToMemory, context) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.addPointAnnotation(options, pushToMemory, context));\n  }\n  removeAnnotation(id, options) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.removeAnnotation(id, options));\n  }\n  clearAnnotations(options) {\n    this.ngZone.runOutsideAngular(() => this.chartInstance()?.clearAnnotations(options));\n  }\n  dataURI(options) {\n    return this.chartInstance()?.dataURI(options);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function ChartComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ChartComponent)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ChartComponent,\n      selectors: [[\"apx-chart\"]],\n      viewQuery: function ChartComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuerySignal(ctx.chartElement, _c0, 5);\n        }\n        if (rf & 2) {\n          i0.ɵɵqueryAdvance();\n        }\n      },\n      inputs: {\n        chart: [1, \"chart\"],\n        annotations: [1, \"annotations\"],\n        colors: [1, \"colors\"],\n        dataLabels: [1, \"dataLabels\"],\n        series: [1, \"series\"],\n        stroke: [1, \"stroke\"],\n        labels: [1, \"labels\"],\n        legend: [1, \"legend\"],\n        markers: [1, \"markers\"],\n        noData: [1, \"noData\"],\n        parsing: [1, \"parsing\"],\n        fill: [1, \"fill\"],\n        tooltip: [1, \"tooltip\"],\n        plotOptions: [1, \"plotOptions\"],\n        responsive: [1, \"responsive\"],\n        xaxis: [1, \"xaxis\"],\n        yaxis: [1, \"yaxis\"],\n        forecastDataPoints: [1, \"forecastDataPoints\"],\n        grid: [1, \"grid\"],\n        states: [1, \"states\"],\n        title: [1, \"title\"],\n        subtitle: [1, \"subtitle\"],\n        theme: [1, \"theme\"],\n        autoUpdateSeries: [1, \"autoUpdateSeries\"]\n      },\n      outputs: {\n        chartReady: \"chartReady\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 2,\n      vars: 0,\n      consts: [[\"chart\", \"\"]],\n      template: function ChartComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵdomElement(0, \"div\", null, 0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ChartComponent, [{\n    type: Component,\n    args: [{\n      selector: \"apx-chart\",\n      template: `<div #chart></div>`,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      standalone: true\n    }]\n  }], null, null);\n})();\nconst declarations = [ChartComponent];\nclass NgApexchartsModule {\n  /** @nocollapse */static {\n    this.ɵfac = function NgApexchartsModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgApexchartsModule)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgApexchartsModule,\n      imports: [ChartComponent],\n      exports: [ChartComponent]\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgApexchartsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [declarations],\n      exports: [declarations]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ng-apexcharts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ChartComponent, NgApexchartsModule };\n","/**\n * @license Angular v20.2.1\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { assertInInjectionContext, inject, DestroyRef, RuntimeError, Injector, assertNotInReactiveContext, signal, PendingTasks } from './root_effect_scheduler.mjs';\nimport { getOutputDestroyRef, effect, untracked, computed, resource, encapsulateResourceError } from './resource.mjs';\nimport './not_found.mjs';\nimport './signal.mjs';\nimport '@angular/core/primitives/signals';\nimport '@angular/core/primitives/di';\nimport './untracked.mjs';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi 19.0\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        ngDevMode && assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable((subscriber) => {\n        if (destroyRef.destroyed) {\n            subscriber.next();\n            return;\n        }\n        const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    source;\n    destroyed = false;\n    destroyRef = inject(DestroyRef);\n    constructor(source) {\n        this.source = source;\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new RuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: (value) => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi 19.0\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi 19.0\n */\nfunction outputToObservable(ref) {\n    const destroyRef = getOutputDestroyRef(ref);\n    return new Observable((observer) => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe((v) => observer.next(v));\n        return () => {\n            subscription.unsubscribe();\n            unregisterOnDestroy?.();\n        };\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @publicApi 20.0\n */\nfunction toObservable(source, options) {\n    if (ngDevMode && !options?.injector) {\n        assertInInjectionContext(toObservable);\n    }\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n */\nfunction toSignal(source, options) {\n    typeof ngDevMode !== 'undefined' &&\n        ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    if (ngDevMode && requiresCleanup && !options?.injector) {\n        assertInInjectionContext(toSignal);\n    }\n    const cleanupRef = requiresCleanup\n        ? (options?.injector?.get(DestroyRef) ?? inject(DestroyRef))\n        : null;\n    const equal = makeToSignalEqual(options?.equal);\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ }, { equal });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue }, { equal });\n    }\n    let destroyUnregisterFn;\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: (value) => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: (error) => {\n            state.set({ kind: 2 /* StateKind.Error */, error });\n            destroyUnregisterFn?.();\n        },\n        complete: () => {\n            destroyUnregisterFn?.();\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                throw new RuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                    '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    }, { equal: options?.equal });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n    return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Operator which makes the application unstable until the observable emits, completes, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @developerPreview 20.0\n */\nfunction pendingUntilEvent(injector) {\n    if (injector === undefined) {\n        ngDevMode && assertInInjectionContext(pendingUntilEvent);\n        injector = inject(Injector);\n    }\n    const taskService = injector.get(PendingTasks);\n    return (sourceObservable) => {\n        return new Observable((originalSubscriber) => {\n            // create a new task on subscription\n            const removeTask = taskService.add();\n            let cleanedUp = false;\n            function cleanupTask() {\n                if (cleanedUp) {\n                    return;\n                }\n                removeTask();\n                cleanedUp = true;\n            }\n            const innerSubscription = sourceObservable.subscribe({\n                next: (v) => {\n                    originalSubscriber.next(v);\n                    cleanupTask();\n                },\n                complete: () => {\n                    originalSubscriber.complete();\n                    cleanupTask();\n                },\n                error: (e) => {\n                    originalSubscriber.error(e);\n                    cleanupTask();\n                },\n            });\n            innerSubscription.add(() => {\n                originalSubscriber.unsubscribe();\n                cleanupTask();\n            });\n            return innerSubscription;\n        });\n    };\n}\n\nfunction rxResource(opts) {\n    if (ngDevMode && !opts?.injector) {\n        assertInInjectionContext(rxResource);\n    }\n    return resource({\n        ...opts,\n        loader: undefined,\n        stream: (params) => {\n            let sub;\n            // Track the abort listener so it can be removed if the Observable completes (as a memory\n            // optimization).\n            const onAbort = () => sub.unsubscribe();\n            params.abortSignal.addEventListener('abort', onAbort);\n            // Start off stream as undefined.\n            const stream = signal({ value: undefined });\n            let resolve;\n            const promise = new Promise((r) => (resolve = r));\n            function send(value) {\n                stream.set(value);\n                resolve?.(stream);\n                resolve = undefined;\n            }\n            // TODO(alxhub): remove after g3 updated to rename loader -> stream\n            const streamFn = opts.stream ?? opts.loader;\n            if (streamFn === undefined) {\n                throw new RuntimeError(990 /* ɵRuntimeErrorCode.MUST_PROVIDE_STREAM_OPTION */, ngDevMode && `Must provide \\`stream\\` option.`);\n            }\n            sub = streamFn(params).subscribe({\n                next: (value) => send({ value }),\n                error: (error) => {\n                    send({ error: encapsulateResourceError(error) });\n                    params.abortSignal.removeEventListener('abort', onAbort);\n                },\n                complete: () => {\n                    if (resolve) {\n                        send({\n                            error: new RuntimeError(991 /* ɵRuntimeErrorCode.RESOURCE_COMPLETED_BEFORE_PRODUCING_VALUE */, ngDevMode && 'Resource completed before producing a value'),\n                        });\n                    }\n                    params.abortSignal.removeEventListener('abort', onAbort);\n                },\n            });\n            return promise;\n        },\n    });\n}\n\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal };\n\n","import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, NgZone, input, output, Directive, NgModule } from '@angular/core';\nimport { outputFromObservable, outputToObservable } from '@angular/core/rxjs-interop';\nimport { ReplaySubject, Subscription, Subject, asyncScheduler, Observable } from 'rxjs';\nimport { throttleTime, switchMap } from 'rxjs/operators';\nconst NGX_ECHARTS_CONFIG = new InjectionToken('NGX_ECHARTS_CONFIG');\nclass ChangeFilterV2 {\n  constructor() {\n    this.subject = new ReplaySubject(1);\n    this.subscriptions = new Subscription();\n  }\n  doFilter(changes) {\n    this.subject.next(changes);\n  }\n  dispose() {\n    this.subscriptions.unsubscribe();\n  }\n  notEmpty(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key]) {\n        const value = changes[key].currentValue;\n        if (value !== undefined && value !== null) {\n          handler(value);\n        }\n      }\n    }));\n  }\n  has(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key]) {\n        const value = changes[key].currentValue;\n        handler(value);\n      }\n    }));\n  }\n  notFirst(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key] && !changes[key].isFirstChange()) {\n        const value = changes[key].currentValue;\n        handler(value);\n      }\n    }));\n  }\n  notFirstAndEmpty(key, handler) {\n    this.subscriptions.add(this.subject.subscribe(changes => {\n      if (changes[key] && !changes[key].isFirstChange()) {\n        const value = changes[key].currentValue;\n        if (value !== undefined && value !== null) {\n          handler(value);\n        }\n      }\n    }));\n  }\n}\nclass NgxEchartsDirective {\n  constructor() {\n    this.el = inject(ElementRef);\n    this.ngZone = inject(NgZone);\n    this.config = inject(NGX_ECHARTS_CONFIG);\n    this.options = input(null);\n    this.theme = input(this.config.theme ?? null);\n    this.initOpts = input(null);\n    this.merge = input(null);\n    this.autoResize = input(true);\n    this.loading = input(false);\n    this.loadingType = input('default');\n    this.loadingOpts = input(null);\n    // ngx-echarts events\n    this.chartInit = output();\n    this.optionsError = output();\n    // echarts mouse events\n    this.chartClick = outputFromObservable(this.createLazyEvent('click'));\n    this.chartDblClick = outputFromObservable(this.createLazyEvent('dblclick'));\n    this.chartMouseDown = outputFromObservable(this.createLazyEvent('mousedown'));\n    this.chartMouseMove = outputFromObservable(this.createLazyEvent('mousemove'));\n    this.chartMouseUp = outputFromObservable(this.createLazyEvent('mouseup'));\n    this.chartMouseOver = outputFromObservable(this.createLazyEvent('mouseover'));\n    this.chartMouseOut = outputFromObservable(this.createLazyEvent('mouseout'));\n    this.chartGlobalOut = outputFromObservable(this.createLazyEvent('globalout'));\n    this.chartContextMenu = outputFromObservable(this.createLazyEvent('contextmenu'));\n    // echarts events\n    this.chartHighlight = outputFromObservable(this.createLazyEvent('highlight'));\n    this.chartDownplay = outputFromObservable(this.createLazyEvent('downplay'));\n    this.chartSelectChanged = outputFromObservable(this.createLazyEvent('selectchanged'));\n    this.chartLegendSelectChanged = outputFromObservable(this.createLazyEvent('legendselectchanged'));\n    this.chartLegendSelected = outputFromObservable(this.createLazyEvent('legendselected'));\n    this.chartLegendUnselected = outputFromObservable(this.createLazyEvent('legendunselected'));\n    this.chartLegendLegendSelectAll = outputFromObservable(this.createLazyEvent('legendselectall'));\n    this.chartLegendLegendInverseSelect = outputFromObservable(this.createLazyEvent('legendinverseselect'));\n    this.chartLegendScroll = outputFromObservable(this.createLazyEvent('legendscroll'));\n    this.chartDataZoom = outputFromObservable(this.createLazyEvent('datazoom'));\n    this.chartDataRangeSelected = outputFromObservable(this.createLazyEvent('datarangeselected'));\n    this.chartGraphRoam = outputFromObservable(this.createLazyEvent('graphroam'));\n    this.chartGeoRoam = outputFromObservable(this.createLazyEvent('georoam'));\n    this.chartTreeRoam = outputFromObservable(this.createLazyEvent('treeroam'));\n    this.chartTimelineChanged = outputFromObservable(this.createLazyEvent('timelinechanged'));\n    this.chartTimelinePlayChanged = outputFromObservable(this.createLazyEvent('timelineplaychanged'));\n    this.chartRestore = outputFromObservable(this.createLazyEvent('restore'));\n    this.chartDataViewChanged = outputFromObservable(this.createLazyEvent('dataviewchanged'));\n    this.chartMagicTypeChanged = outputFromObservable(this.createLazyEvent('magictypechanged'));\n    this.chartGeoSelectChanged = outputFromObservable(this.createLazyEvent('geoselectchanged'));\n    this.chartGeoSelected = outputFromObservable(this.createLazyEvent('geoselected'));\n    this.chartGeoUnselected = outputFromObservable(this.createLazyEvent('geounselected'));\n    this.chartAxisAreaSelected = outputFromObservable(this.createLazyEvent('axisareaselected'));\n    this.chartBrush = outputFromObservable(this.createLazyEvent('brush'));\n    this.chartBrushEnd = outputFromObservable(this.createLazyEvent('brushend'));\n    this.chartBrushSelected = outputFromObservable(this.createLazyEvent('brushselected'));\n    this.chartGlobalCursorTaken = outputFromObservable(this.createLazyEvent('globalcursortaken'));\n    this.chartRendered = outputFromObservable(this.createLazyEvent('rendered'));\n    this.chartFinished = outputFromObservable(this.createLazyEvent('finished'));\n    this.animationFrameID = null;\n    this.chart$ = new ReplaySubject(1);\n    this.resize$ = new Subject();\n    this.changeFilter = new ChangeFilterV2();\n    this.resizeObFired = false;\n    this.echarts = this.config.echarts;\n  }\n  ngOnChanges(changes) {\n    this.changeFilter.doFilter(changes);\n  }\n  ngOnInit() {\n    if (!window.ResizeObserver) {\n      throw new Error('please install a polyfill for ResizeObserver');\n    }\n    this.resizeSub = this.resize$.pipe(throttleTime(100, asyncScheduler, {\n      leading: false,\n      trailing: true\n    })).subscribe(() => this.resize());\n    if (this.autoResize()) {\n      // https://github.com/xieziyu/ngx-echarts/issues/413\n      this.resizeOb = this.ngZone.runOutsideAngular(() => new window.ResizeObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.el.nativeElement) {\n            // Ignore first fire on insertion, no resize actually happened\n            if (!this.resizeObFired) {\n              this.resizeObFired = true;\n            } else {\n              this.animationFrameID = window.requestAnimationFrame(() => {\n                this.resize$.next();\n              });\n            }\n          }\n        }\n      }));\n      this.resizeOb.observe(this.el.nativeElement);\n    }\n    this.changeFilter.notFirstAndEmpty('options', opt => this.onOptionsChange(opt));\n    this.changeFilter.notFirstAndEmpty('merge', opt => this.setOption(opt));\n    this.changeFilter.has('loading', v => this.toggleLoading(!!v));\n    this.changeFilter.notFirst('theme', () => this.refreshChart());\n  }\n  ngOnDestroy() {\n    window.clearTimeout(this.initChartTimer);\n    if (this.resizeSub) {\n      this.resizeSub.unsubscribe();\n    }\n    if (this.animationFrameID) {\n      window.cancelAnimationFrame(this.animationFrameID);\n    }\n    if (this.resizeOb) {\n      this.resizeOb.unobserve(this.el.nativeElement);\n    }\n    if (this.loadingSub) {\n      this.loadingSub.unsubscribe();\n    }\n    this.changeFilter.dispose();\n    this.dispose();\n  }\n  ngAfterViewInit() {\n    this.initChartTimer = window.setTimeout(() => this.initChart());\n  }\n  dispose() {\n    if (this.chart) {\n      if (!this.chart.isDisposed()) {\n        this.chart.dispose();\n      }\n      this.chart = null;\n    }\n  }\n  /**\n   * resize chart\n   */\n  resize() {\n    if (this.chart) {\n      this.chart.resize();\n    }\n  }\n  toggleLoading(loading) {\n    if (this.chart) {\n      loading ? this.chart.showLoading(this.loadingType(), this.loadingOpts()) : this.chart.hideLoading();\n    } else {\n      this.loadingSub = this.chart$.subscribe(chart => loading ? chart.showLoading(this.loadingType(), this.loadingOpts()) : chart.hideLoading());\n    }\n  }\n  setOption(option, opts) {\n    if (this.chart) {\n      try {\n        this.chart.setOption(option, opts);\n      } catch (e) {\n        console.error(e);\n        this.optionsError.emit(e);\n      }\n    }\n  }\n  /**\n   * dispose old chart and create a new one.\n   */\n  async refreshChart() {\n    this.dispose();\n    await this.initChart();\n  }\n  createChart() {\n    const dom = this.el.nativeElement;\n    if (window && window.getComputedStyle) {\n      const prop = window.getComputedStyle(dom, null).getPropertyValue('height');\n      if ((!prop || prop === '0px') && (!dom.style.height || dom.style.height === '0px')) {\n        dom.style.height = '400px';\n      }\n    }\n    // here a bit tricky: we check if the echarts module is provided as function returning native import('...') then use the promise\n    // otherwise create the function that imitates behaviour above with a provided as is module\n    return this.ngZone.runOutsideAngular(() => {\n      const load = typeof this.echarts === 'function' ? this.echarts : () => Promise.resolve(this.echarts);\n      return load().then(({\n        init\n      }) => init(dom, this.theme() ?? this.config?.theme, this.initOpts()));\n    });\n  }\n  async initChart() {\n    await this.onOptionsChange(this.options());\n    const merge = this.merge();\n    if (merge && this.chart) {\n      this.setOption(merge);\n    }\n  }\n  async onOptionsChange(opt) {\n    if (!opt) {\n      return;\n    }\n    if (this.chart) {\n      this.setOption(this.options(), true);\n    } else {\n      this.chart = await this.createChart();\n      this.chart$.next(this.chart);\n      this.chartInit.emit(this.chart);\n      this.setOption(this.options(), true);\n    }\n  }\n  // allows to lazily bind to only those events that are requested through the `output()` by parent components\n  // see https://stackoverflow.com/questions/51787972/optimal-reentering-the-ngzone-from-eventemitter-event for more info\n  createLazyEvent(eventName) {\n    return outputToObservable(this.chartInit).pipe(switchMap(chart => new Observable(observer => {\n      chart.on(eventName, data => this.ngZone.run(() => observer.next(data)));\n      return () => {\n        if (this.chart) {\n          if (!this.chart.isDisposed()) {\n            chart.off(eventName);\n          }\n        }\n      };\n    })));\n  }\n  static {\n    this.ɵfac = function NgxEchartsDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgxEchartsDirective)();\n    };\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgxEchartsDirective,\n      selectors: [[\"echarts\"], [\"\", \"echarts\", \"\"]],\n      inputs: {\n        options: [1, \"options\"],\n        theme: [1, \"theme\"],\n        initOpts: [1, \"initOpts\"],\n        merge: [1, \"merge\"],\n        autoResize: [1, \"autoResize\"],\n        loading: [1, \"loading\"],\n        loadingType: [1, \"loadingType\"],\n        loadingOpts: [1, \"loadingOpts\"]\n      },\n      outputs: {\n        chartInit: \"chartInit\",\n        optionsError: \"optionsError\",\n        chartClick: \"chartClick\",\n        chartDblClick: \"chartDblClick\",\n        chartMouseDown: \"chartMouseDown\",\n        chartMouseMove: \"chartMouseMove\",\n        chartMouseUp: \"chartMouseUp\",\n        chartMouseOver: \"chartMouseOver\",\n        chartMouseOut: \"chartMouseOut\",\n        chartGlobalOut: \"chartGlobalOut\",\n        chartContextMenu: \"chartContextMenu\",\n        chartHighlight: \"chartHighlight\",\n        chartDownplay: \"chartDownplay\",\n        chartSelectChanged: \"chartSelectChanged\",\n        chartLegendSelectChanged: \"chartLegendSelectChanged\",\n        chartLegendSelected: \"chartLegendSelected\",\n        chartLegendUnselected: \"chartLegendUnselected\",\n        chartLegendLegendSelectAll: \"chartLegendLegendSelectAll\",\n        chartLegendLegendInverseSelect: \"chartLegendLegendInverseSelect\",\n        chartLegendScroll: \"chartLegendScroll\",\n        chartDataZoom: \"chartDataZoom\",\n        chartDataRangeSelected: \"chartDataRangeSelected\",\n        chartGraphRoam: \"chartGraphRoam\",\n        chartGeoRoam: \"chartGeoRoam\",\n        chartTreeRoam: \"chartTreeRoam\",\n        chartTimelineChanged: \"chartTimelineChanged\",\n        chartTimelinePlayChanged: \"chartTimelinePlayChanged\",\n        chartRestore: \"chartRestore\",\n        chartDataViewChanged: \"chartDataViewChanged\",\n        chartMagicTypeChanged: \"chartMagicTypeChanged\",\n        chartGeoSelectChanged: \"chartGeoSelectChanged\",\n        chartGeoSelected: \"chartGeoSelected\",\n        chartGeoUnselected: \"chartGeoUnselected\",\n        chartAxisAreaSelected: \"chartAxisAreaSelected\",\n        chartBrush: \"chartBrush\",\n        chartBrushEnd: \"chartBrushEnd\",\n        chartBrushSelected: \"chartBrushSelected\",\n        chartGlobalCursorTaken: \"chartGlobalCursorTaken\",\n        chartRendered: \"chartRendered\",\n        chartFinished: \"chartFinished\"\n      },\n      exportAs: [\"echarts\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEchartsDirective, [{\n    type: Directive,\n    args: [{\n      standalone: true,\n      selector: 'echarts, [echarts]',\n      exportAs: 'echarts'\n    }]\n  }], null, null);\n})();\nfunction provideEchartsCore(config) {\n  return {\n    provide: NGX_ECHARTS_CONFIG,\n    useValue: config\n  };\n}\nclass NgxEchartsModule {\n  static forRoot(config) {\n    return {\n      ngModule: NgxEchartsModule,\n      providers: [provideEchartsCore(config)]\n    };\n  }\n  static forChild() {\n    return {\n      ngModule: NgxEchartsModule\n    };\n  }\n  static {\n    this.ɵfac = function NgxEchartsModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgxEchartsModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgxEchartsModule,\n      imports: [NgxEchartsDirective],\n      exports: [NgxEchartsDirective]\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxEchartsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgxEchartsDirective],\n      exports: [NgxEchartsDirective]\n    }]\n  }], null, null);\n})();\n\n/*\n * Public API Surface of ngx-echarts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGX_ECHARTS_CONFIG, NgxEchartsDirective, NgxEchartsModule, provideEchartsCore };\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,IAAM,MAAM,CAAC,OAAO;AACpB,IAAM,kBAAN,MAAM,gBAAe;AAAA,EACnB,cAAc;AACZ,SAAK,QAAQ,MAAM;AACnB,SAAK,cAAc,MAAM;AACzB,SAAK,SAAS,MAAM;AACpB,SAAK,aAAa,MAAM;AACxB,SAAK,SAAS,MAAM;AACpB,SAAK,SAAS,MAAM;AACpB,SAAK,SAAS,MAAM;AACpB,SAAK,SAAS,MAAM;AACpB,SAAK,UAAU,MAAM;AACrB,SAAK,SAAS,MAAM;AACpB,SAAK,UAAU,MAAM;AACrB,SAAK,OAAO,MAAM;AAClB,SAAK,UAAU,MAAM;AACrB,SAAK,cAAc,MAAM;AACzB,SAAK,aAAa,MAAM;AACxB,SAAK,QAAQ,MAAM;AACnB,SAAK,QAAQ,MAAM;AACnB,SAAK,qBAAqB,MAAM;AAChC,SAAK,OAAO,MAAM;AAClB,SAAK,SAAS,MAAM;AACpB,SAAK,QAAQ,MAAM;AACnB,SAAK,WAAW,MAAM;AACtB,SAAK,QAAQ,MAAM;AACnB,SAAK,mBAAmB,MAAM,IAAI;AAClC,SAAK,aAAa,OAAO;AAKzB,SAAK,gBAAgB,OAAO,IAAI;AAChC,SAAK,eAAe,UAAU,SAAS,OAAO;AAC9C,SAAK,SAAS,OAAO,MAAM;AAC3B,SAAK,YAAY,kBAAkB,OAAO,WAAW,CAAC;AAAA,EACxD;AAAA,EACA,YAAY,SAAS;AACnB,QAAI,CAAC,KAAK,UAAW;AACrB,SAAK,OAAO,kBAAkB,MAAM;AAClC,oBAAc,SAAS,MAAM,KAAK,QAAQ,OAAO,CAAC;AAAA,IACpD,CAAC;AAAA,EACH;AAAA,EACA,cAAc;AACZ,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,QAAQ,SAAS;AACf,UAAM,qBAAqB,KAAK,iBAAiB,KAAK,OAAO,KAAK,OAAO,EAAE,OAAO,OAAK,MAAM,QAAQ,EAAE,WAAW;AAClH,QAAI,oBAAoB;AACtB,WAAK,aAAa,KAAK,OAAO,GAAG,IAAI;AACrC;AAAA,IACF;AACA,SAAK,cAAc;AAAA,EACrB;AAAA,EACM,gBAAgB;AAAA;AACpB,YAAM;AAAA,QACJ,SAAS;AAAA,MACX,IAAI,MAAM,OAAO,qBAAY;AAC7B,aAAO,eAAe;AACtB,YAAM,UAAU,CAAC;AACjB,YAAM,aAAa,CAAC,eAAe,SAAS,UAAU,cAAc,UAAU,UAAU,UAAU,UAAU,QAAQ,WAAW,eAAe,cAAc,WAAW,UAAU,WAAW,SAAS,SAAS,sBAAsB,QAAQ,UAAU,SAAS,YAAY,OAAO;AAClR,iBAAW,QAAQ,cAAY;AAC7B,cAAM,QAAQ,KAAK,QAAQ,EAAE;AAC7B,YAAI,OAAO;AACT,kBAAQ,QAAQ,IAAI;AAAA,QACtB;AAAA,MACF,CAAC;AACD,WAAK,QAAQ;AACb,YAAM,gBAAgB,KAAK,OAAO,kBAAkB,MAAM,IAAI,WAAW,KAAK,aAAa,EAAE,eAAe,OAAO,CAAC;AACpH,WAAK,cAAc,IAAI,aAAa;AACpC,WAAK,OAAO;AACZ,WAAK,WAAW,KAAK;AAAA,QACnB,UAAU;AAAA,MACZ,CAAC;AAAA,IACH;AAAA;AAAA,EACA,SAAS;AACP,WAAO,KAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,OAAO,CAAC;AAAA,EAC3E;AAAA,EACA,cAAc,SAAS,aAAa,SAAS,oBAAoB;AAC/D,WAAO,KAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,cAAc,SAAS,aAAa,SAAS,kBAAkB,CAAC;AAAA,EACnI;AAAA,EACA,aAAa,WAAW,SAAS;AAC/B,WAAO,KAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,aAAa,WAAW,OAAO,CAAC;AAAA,EACnG;AAAA,EACA,aAAa,WAAW,SAAS;AAC/B,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,aAAa,WAAW,OAAO,CAAC;AAAA,EAC5F;AAAA,EACA,WAAW,SAAS;AAClB,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,WAAW,OAAO,CAAC;AAAA,EAC/E;AAAA,EACA,gBAAgB,YAAY;AAC1B,WAAO,KAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,gBAAgB,UAAU,CAAC;AAAA,EAC9F;AAAA,EACA,aAAa,YAAY;AACvB,WAAO,KAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,aAAa,UAAU,CAAC;AAAA,EAC3F;AAAA,EACA,WAAW,YAAY;AACrB,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,WAAW,UAAU,CAAC;AAAA,EAClF;AAAA,EACA,WAAW,YAAY;AACrB,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,WAAW,UAAU,CAAC;AAAA,EAClF;AAAA,EACA,cAAc;AACZ,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,YAAY,CAAC;AAAA,EACzE;AAAA,EACA,MAAM,KAAK,KAAK;AACd,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,MAAM,KAAK,GAAG,CAAC;AAAA,EAC3E;AAAA,EACA,yBAAyB,aAAa,gBAAgB;AACpD,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,yBAAyB,aAAa,cAAc,CAAC;AAAA,EACjH;AAAA,EACA,UAAU;AACR,SAAK,cAAc,GAAG,QAAQ;AAC9B,SAAK,cAAc,IAAI,IAAI;AAAA,EAC7B;AAAA,EACA,UAAU,YAAY;AACpB,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,UAAU,UAAU,CAAC;AAAA,EACjF;AAAA,EACA,QAAQ;AACN,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,MAAM,CAAC;AAAA,EACnE;AAAA,EACA,mBAAmB,SAAS,cAAc,SAAS;AACjD,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,mBAAmB,SAAS,cAAc,OAAO,CAAC;AAAA,EAC9G;AAAA,EACA,mBAAmB,SAAS,cAAc,SAAS;AACjD,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,mBAAmB,SAAS,cAAc,OAAO,CAAC;AAAA,EAC9G;AAAA,EACA,mBAAmB,SAAS,cAAc,SAAS;AACjD,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,mBAAmB,SAAS,cAAc,OAAO,CAAC;AAAA,EAC9G;AAAA,EACA,iBAAiB,IAAI,SAAS;AAC5B,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,iBAAiB,IAAI,OAAO,CAAC;AAAA,EACzF;AAAA,EACA,iBAAiB,SAAS;AACxB,SAAK,OAAO,kBAAkB,MAAM,KAAK,cAAc,GAAG,iBAAiB,OAAO,CAAC;AAAA,EACrF;AAAA,EACA,QAAQ,SAAS;AACf,WAAO,KAAK,cAAc,GAAG,QAAQ,OAAO;AAAA,EAC9C;AA8DF;AA3DI,gBAAK,YAAO,SAAS,uBAAuB,mBAAmB;AAC7D,SAAO,KAAK,qBAAqB,iBAAgB;AACnD;AAIA,gBAAK,YAAsB,gBAAG,4BAAkB;AAAA,EAC9C,MAAM;AAAA,EACN,WAAW,CAAC,CAAC,WAAW,CAAC;AAAA,EACzB,WAAW,SAAS,qBAAqB,IAAI,KAAK;AAChD,QAAI,KAAK,GAAG;AACV,MAAG,4BAAkB,IAAI,cAAc,KAAK,CAAC;AAAA,IAC/C;AACA,QAAI,KAAK,GAAG;AACV,MAAG,yBAAe;AAAA,IACpB;AAAA,EACF;AAAA,EACA,QAAQ;AAAA,IACN,OAAO,CAAC,GAAG,OAAO;AAAA,IAClB,aAAa,CAAC,GAAG,aAAa;AAAA,IAC9B,QAAQ,CAAC,GAAG,QAAQ;AAAA,IACpB,YAAY,CAAC,GAAG,YAAY;AAAA,IAC5B,QAAQ,CAAC,GAAG,QAAQ;AAAA,IACpB,QAAQ,CAAC,GAAG,QAAQ;AAAA,IACpB,QAAQ,CAAC,GAAG,QAAQ;AAAA,IACpB,QAAQ,CAAC,GAAG,QAAQ;AAAA,IACpB,SAAS,CAAC,GAAG,SAAS;AAAA,IACtB,QAAQ,CAAC,GAAG,QAAQ;AAAA,IACpB,SAAS,CAAC,GAAG,SAAS;AAAA,IACtB,MAAM,CAAC,GAAG,MAAM;AAAA,IAChB,SAAS,CAAC,GAAG,SAAS;AAAA,IACtB,aAAa,CAAC,GAAG,aAAa;AAAA,IAC9B,YAAY,CAAC,GAAG,YAAY;AAAA,IAC5B,OAAO,CAAC,GAAG,OAAO;AAAA,IAClB,OAAO,CAAC,GAAG,OAAO;AAAA,IAClB,oBAAoB,CAAC,GAAG,oBAAoB;AAAA,IAC5C,MAAM,CAAC,GAAG,MAAM;AAAA,IAChB,QAAQ,CAAC,GAAG,QAAQ;AAAA,IACpB,OAAO,CAAC,GAAG,OAAO;AAAA,IAClB,UAAU,CAAC,GAAG,UAAU;AAAA,IACxB,OAAO,CAAC,GAAG,OAAO;AAAA,IAClB,kBAAkB,CAAC,GAAG,kBAAkB;AAAA,EAC1C;AAAA,EACA,SAAS;AAAA,IACP,YAAY;AAAA,EACd;AAAA,EACA,UAAU,CAAI,8BAAoB;AAAA,EAClC,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ,CAAC,CAAC,SAAS,EAAE,CAAC;AAAA,EACtB,UAAU,SAAS,wBAAwB,IAAI,KAAK;AAClD,QAAI,KAAK,GAAG;AACV,MAAG,uBAAa,GAAG,OAAO,MAAM,CAAC;AAAA,IACnC;AAAA,EACF;AAAA,EACA,eAAe;AAAA,EACf,iBAAiB;AACnB,CAAC;AArML,IAAM,iBAAN;AAAA,CAwMC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,gBAAgB,CAAC;AAAA,IACvF,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,UAAU;AAAA,MACV,UAAU;AAAA,MACV,iBAAiB,wBAAwB;AAAA,MACzC,YAAY;AAAA,IACd,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;AACH,IAAM,eAAe,CAAC,cAAc;AACpC,IAAM,sBAAN,MAAM,oBAAmB;AAkBzB;AAhBI,oBAAK,YAAO,SAAS,2BAA2B,mBAAmB;AACjE,SAAO,KAAK,qBAAqB,qBAAoB;AACvD;AAIA,oBAAK,YAAsB,gBAAG,2BAAiB;AAAA,EAC7C,MAAM;AAAA,EACN,SAAS,CAAC,cAAc;AAAA,EACxB,SAAS,CAAC,cAAc;AAC1B,CAAC;AAID,oBAAK,YAAsB,gBAAG,2BAAiB,CAAC,CAAC;AAhBrD,IAAM,qBAAN;AAAA,CAmBC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,oBAAoB,CAAC;AAAA,IAC3F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,SAAS,CAAC,YAAY;AAAA,MACtB,SAAS,CAAC,YAAY;AAAA,IACxB,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;;;AC1NH,SAAS,mBAAmB,YAAY;AACpC,MAAI,CAAC,YAAY;AACb,iBAAa,yBAAyB,kBAAkB;AACxD,iBAAa,OAAO,UAAU;AAAA,EAClC;AACA,QAAM,aAAa,IAAI,WAAW,CAAC,eAAe;AAC9C,QAAI,WAAW,WAAW;AACtB,iBAAW,KAAK;AAChB;AAAA,IACJ;AACA,UAAM,eAAe,WAAW,UAAU,WAAW,KAAK,KAAK,UAAU,CAAC;AAC1E,WAAO;AAAA,EACX,CAAC;AACD,SAAO,CAAC,WAAW;AACf,WAAO,OAAO,KAAK,UAAU,UAAU,CAAC;AAAA,EAC5C;AACJ;AAQA,IAAM,0BAAN,MAA8B;AAAA,EAC1B;AAAA,EACA,YAAY;AAAA,EACZ,aAAa,OAAO,UAAU;AAAA,EAC9B,YAAY,QAAQ;AAChB,SAAK,SAAS;AACd,SAAK,WAAW,UAAU,MAAM;AAC5B,WAAK,YAAY;AAAA,IACrB,CAAC;AAAA,EACL;AAAA,EACA,UAAU,YAAY;AAClB,QAAI,KAAK,WAAW;AAChB,YAAM,IAAI,aAAa,KAAkD,aACrE,gGACkD;AAAA,IAC1D;AAEA,UAAM,eAAe,KAAK,OAAO,KAAK,mBAAmB,KAAK,UAAU,CAAC,EAAE,UAAU;AAAA,MACjF,MAAM,CAAC,UAAU,WAAW,KAAK;AAAA,IACrC,CAAC;AACD,WAAO;AAAA,MACH,aAAa,MAAM,aAAa,YAAY;AAAA,IAChD;AAAA,EACJ;AACJ;AAyBA,SAAS,qBAAqB,YAAY,MAAM;AAC5C,eAAa,yBAAyB,oBAAoB;AAC1D,SAAO,IAAI,wBAAwB,UAAU;AACjD;AAUA,SAAS,mBAAmB,KAAK;AAC7B,QAAM,aAAa,oBAAoB,GAAG;AAC1C,SAAO,IAAI,WAAW,CAAC,aAAa;AAIhC,UAAM,sBAAsB,YAAY,UAAU,MAAM,SAAS,SAAS,CAAC;AAC3E,UAAM,eAAe,IAAI,UAAU,CAAC,MAAM,SAAS,KAAK,CAAC,CAAC;AAC1D,WAAO,MAAM;AACT,mBAAa,YAAY;AACzB,4BAAsB;AAAA,IAC1B;AAAA,EACJ,CAAC;AACL;;;ACxHA,IAAM,qBAAqB,IAAI,eAAe,oBAAoB;AAClE,IAAM,iBAAN,MAAqB;AAAA,EACnB,cAAc;AACZ,SAAK,UAAU,IAAI,cAAc,CAAC;AAClC,SAAK,gBAAgB,IAAI,aAAa;AAAA,EACxC;AAAA,EACA,SAAS,SAAS;AAChB,SAAK,QAAQ,KAAK,OAAO;AAAA,EAC3B;AAAA,EACA,UAAU;AACR,SAAK,cAAc,YAAY;AAAA,EACjC;AAAA,EACA,SAAS,KAAK,SAAS;AACrB,SAAK,cAAc,IAAI,KAAK,QAAQ,UAAU,aAAW;AACvD,UAAI,QAAQ,GAAG,GAAG;AAChB,cAAM,QAAQ,QAAQ,GAAG,EAAE;AAC3B,YAAI,UAAU,UAAa,UAAU,MAAM;AACzC,kBAAQ,KAAK;AAAA,QACf;AAAA,MACF;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AAAA,EACA,IAAI,KAAK,SAAS;AAChB,SAAK,cAAc,IAAI,KAAK,QAAQ,UAAU,aAAW;AACvD,UAAI,QAAQ,GAAG,GAAG;AAChB,cAAM,QAAQ,QAAQ,GAAG,EAAE;AAC3B,gBAAQ,KAAK;AAAA,MACf;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AAAA,EACA,SAAS,KAAK,SAAS;AACrB,SAAK,cAAc,IAAI,KAAK,QAAQ,UAAU,aAAW;AACvD,UAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,GAAG,EAAE,cAAc,GAAG;AACjD,cAAM,QAAQ,QAAQ,GAAG,EAAE;AAC3B,gBAAQ,KAAK;AAAA,MACf;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AAAA,EACA,iBAAiB,KAAK,SAAS;AAC7B,SAAK,cAAc,IAAI,KAAK,QAAQ,UAAU,aAAW;AACvD,UAAI,QAAQ,GAAG,KAAK,CAAC,QAAQ,GAAG,EAAE,cAAc,GAAG;AACjD,cAAM,QAAQ,QAAQ,GAAG,EAAE;AAC3B,YAAI,UAAU,UAAa,UAAU,MAAM;AACzC,kBAAQ,KAAK;AAAA,QACf;AAAA,MACF;AAAA,IACF,CAAC,CAAC;AAAA,EACJ;AACF;AACA,IAAM,uBAAN,MAAM,qBAAoB;AAAA,EACxB,cAAc;AACZ,SAAK,KAAK,OAAO,UAAU;AAC3B,SAAK,SAAS,OAAO,MAAM;AAC3B,SAAK,SAAS,OAAO,kBAAkB;AACvC,SAAK,UAAU,MAAM,IAAI;AACzB,SAAK,QAAQ,MAAM,KAAK,OAAO,SAAS,IAAI;AAC5C,SAAK,WAAW,MAAM,IAAI;AAC1B,SAAK,QAAQ,MAAM,IAAI;AACvB,SAAK,aAAa,MAAM,IAAI;AAC5B,SAAK,UAAU,MAAM,KAAK;AAC1B,SAAK,cAAc,MAAM,SAAS;AAClC,SAAK,cAAc,MAAM,IAAI;AAE7B,SAAK,YAAY,OAAO;AACxB,SAAK,eAAe,OAAO;AAE3B,SAAK,aAAa,qBAAqB,KAAK,gBAAgB,OAAO,CAAC;AACpE,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,iBAAiB,qBAAqB,KAAK,gBAAgB,WAAW,CAAC;AAC5E,SAAK,iBAAiB,qBAAqB,KAAK,gBAAgB,WAAW,CAAC;AAC5E,SAAK,eAAe,qBAAqB,KAAK,gBAAgB,SAAS,CAAC;AACxE,SAAK,iBAAiB,qBAAqB,KAAK,gBAAgB,WAAW,CAAC;AAC5E,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,iBAAiB,qBAAqB,KAAK,gBAAgB,WAAW,CAAC;AAC5E,SAAK,mBAAmB,qBAAqB,KAAK,gBAAgB,aAAa,CAAC;AAEhF,SAAK,iBAAiB,qBAAqB,KAAK,gBAAgB,WAAW,CAAC;AAC5E,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,qBAAqB,qBAAqB,KAAK,gBAAgB,eAAe,CAAC;AACpF,SAAK,2BAA2B,qBAAqB,KAAK,gBAAgB,qBAAqB,CAAC;AAChG,SAAK,sBAAsB,qBAAqB,KAAK,gBAAgB,gBAAgB,CAAC;AACtF,SAAK,wBAAwB,qBAAqB,KAAK,gBAAgB,kBAAkB,CAAC;AAC1F,SAAK,6BAA6B,qBAAqB,KAAK,gBAAgB,iBAAiB,CAAC;AAC9F,SAAK,iCAAiC,qBAAqB,KAAK,gBAAgB,qBAAqB,CAAC;AACtG,SAAK,oBAAoB,qBAAqB,KAAK,gBAAgB,cAAc,CAAC;AAClF,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,yBAAyB,qBAAqB,KAAK,gBAAgB,mBAAmB,CAAC;AAC5F,SAAK,iBAAiB,qBAAqB,KAAK,gBAAgB,WAAW,CAAC;AAC5E,SAAK,eAAe,qBAAqB,KAAK,gBAAgB,SAAS,CAAC;AACxE,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,uBAAuB,qBAAqB,KAAK,gBAAgB,iBAAiB,CAAC;AACxF,SAAK,2BAA2B,qBAAqB,KAAK,gBAAgB,qBAAqB,CAAC;AAChG,SAAK,eAAe,qBAAqB,KAAK,gBAAgB,SAAS,CAAC;AACxE,SAAK,uBAAuB,qBAAqB,KAAK,gBAAgB,iBAAiB,CAAC;AACxF,SAAK,wBAAwB,qBAAqB,KAAK,gBAAgB,kBAAkB,CAAC;AAC1F,SAAK,wBAAwB,qBAAqB,KAAK,gBAAgB,kBAAkB,CAAC;AAC1F,SAAK,mBAAmB,qBAAqB,KAAK,gBAAgB,aAAa,CAAC;AAChF,SAAK,qBAAqB,qBAAqB,KAAK,gBAAgB,eAAe,CAAC;AACpF,SAAK,wBAAwB,qBAAqB,KAAK,gBAAgB,kBAAkB,CAAC;AAC1F,SAAK,aAAa,qBAAqB,KAAK,gBAAgB,OAAO,CAAC;AACpE,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,qBAAqB,qBAAqB,KAAK,gBAAgB,eAAe,CAAC;AACpF,SAAK,yBAAyB,qBAAqB,KAAK,gBAAgB,mBAAmB,CAAC;AAC5F,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,gBAAgB,qBAAqB,KAAK,gBAAgB,UAAU,CAAC;AAC1E,SAAK,mBAAmB;AACxB,SAAK,SAAS,IAAI,cAAc,CAAC;AACjC,SAAK,UAAU,IAAI,QAAQ;AAC3B,SAAK,eAAe,IAAI,eAAe;AACvC,SAAK,gBAAgB;AACrB,SAAK,UAAU,KAAK,OAAO;AAAA,EAC7B;AAAA,EACA,YAAY,SAAS;AACnB,SAAK,aAAa,SAAS,OAAO;AAAA,EACpC;AAAA,EACA,WAAW;AACT,QAAI,CAAC,OAAO,gBAAgB;AAC1B,YAAM,IAAI,MAAM,8CAA8C;AAAA,IAChE;AACA,SAAK,YAAY,KAAK,QAAQ,KAAK,aAAa,KAAK,gBAAgB;AAAA,MACnE,SAAS;AAAA,MACT,UAAU;AAAA,IACZ,CAAC,CAAC,EAAE,UAAU,MAAM,KAAK,OAAO,CAAC;AACjC,QAAI,KAAK,WAAW,GAAG;AAErB,WAAK,WAAW,KAAK,OAAO,kBAAkB,MAAM,IAAI,OAAO,eAAe,aAAW;AACvF,mBAAW,SAAS,SAAS;AAC3B,cAAI,MAAM,WAAW,KAAK,GAAG,eAAe;AAE1C,gBAAI,CAAC,KAAK,eAAe;AACvB,mBAAK,gBAAgB;AAAA,YACvB,OAAO;AACL,mBAAK,mBAAmB,OAAO,sBAAsB,MAAM;AACzD,qBAAK,QAAQ,KAAK;AAAA,cACpB,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC,CAAC;AACF,WAAK,SAAS,QAAQ,KAAK,GAAG,aAAa;AAAA,IAC7C;AACA,SAAK,aAAa,iBAAiB,WAAW,SAAO,KAAK,gBAAgB,GAAG,CAAC;AAC9E,SAAK,aAAa,iBAAiB,SAAS,SAAO,KAAK,UAAU,GAAG,CAAC;AACtE,SAAK,aAAa,IAAI,WAAW,OAAK,KAAK,cAAc,CAAC,CAAC,CAAC,CAAC;AAC7D,SAAK,aAAa,SAAS,SAAS,MAAM,KAAK,aAAa,CAAC;AAAA,EAC/D;AAAA,EACA,cAAc;AACZ,WAAO,aAAa,KAAK,cAAc;AACvC,QAAI,KAAK,WAAW;AAClB,WAAK,UAAU,YAAY;AAAA,IAC7B;AACA,QAAI,KAAK,kBAAkB;AACzB,aAAO,qBAAqB,KAAK,gBAAgB;AAAA,IACnD;AACA,QAAI,KAAK,UAAU;AACjB,WAAK,SAAS,UAAU,KAAK,GAAG,aAAa;AAAA,IAC/C;AACA,QAAI,KAAK,YAAY;AACnB,WAAK,WAAW,YAAY;AAAA,IAC9B;AACA,SAAK,aAAa,QAAQ;AAC1B,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,kBAAkB;AAChB,SAAK,iBAAiB,OAAO,WAAW,MAAM,KAAK,UAAU,CAAC;AAAA,EAChE;AAAA,EACA,UAAU;AACR,QAAI,KAAK,OAAO;AACd,UAAI,CAAC,KAAK,MAAM,WAAW,GAAG;AAC5B,aAAK,MAAM,QAAQ;AAAA,MACrB;AACA,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,SAAS;AACP,QAAI,KAAK,OAAO;AACd,WAAK,MAAM,OAAO;AAAA,IACpB;AAAA,EACF;AAAA,EACA,cAAc,SAAS;AACrB,QAAI,KAAK,OAAO;AACd,gBAAU,KAAK,MAAM,YAAY,KAAK,YAAY,GAAG,KAAK,YAAY,CAAC,IAAI,KAAK,MAAM,YAAY;AAAA,IACpG,OAAO;AACL,WAAK,aAAa,KAAK,OAAO,UAAU,WAAS,UAAU,MAAM,YAAY,KAAK,YAAY,GAAG,KAAK,YAAY,CAAC,IAAI,MAAM,YAAY,CAAC;AAAA,IAC5I;AAAA,EACF;AAAA,EACA,UAAU,QAAQ,MAAM;AACtB,QAAI,KAAK,OAAO;AACd,UAAI;AACF,aAAK,MAAM,UAAU,QAAQ,IAAI;AAAA,MACnC,SAAS,GAAG;AACV,gBAAQ,MAAM,CAAC;AACf,aAAK,aAAa,KAAK,CAAC;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIM,eAAe;AAAA;AACnB,WAAK,QAAQ;AACb,YAAM,KAAK,UAAU;AAAA,IACvB;AAAA;AAAA,EACA,cAAc;AACZ,UAAM,MAAM,KAAK,GAAG;AACpB,QAAI,UAAU,OAAO,kBAAkB;AACrC,YAAM,OAAO,OAAO,iBAAiB,KAAK,IAAI,EAAE,iBAAiB,QAAQ;AACzE,WAAK,CAAC,QAAQ,SAAS,WAAW,CAAC,IAAI,MAAM,UAAU,IAAI,MAAM,WAAW,QAAQ;AAClF,YAAI,MAAM,SAAS;AAAA,MACrB;AAAA,IACF;AAGA,WAAO,KAAK,OAAO,kBAAkB,MAAM;AACzC,YAAM,OAAO,OAAO,KAAK,YAAY,aAAa,KAAK,UAAU,MAAM,QAAQ,QAAQ,KAAK,OAAO;AACnG,aAAO,KAAK,EAAE,KAAK,CAAC;AAAA,QAClB;AAAA,MACF,MAAM,KAAK,KAAK,KAAK,MAAM,KAAK,KAAK,QAAQ,OAAO,KAAK,SAAS,CAAC,CAAC;AAAA,IACtE,CAAC;AAAA,EACH;AAAA,EACM,YAAY;AAAA;AAChB,YAAM,KAAK,gBAAgB,KAAK,QAAQ,CAAC;AACzC,YAAM,QAAQ,KAAK,MAAM;AACzB,UAAI,SAAS,KAAK,OAAO;AACvB,aAAK,UAAU,KAAK;AAAA,MACtB;AAAA,IACF;AAAA;AAAA,EACM,gBAAgB,KAAK;AAAA;AACzB,UAAI,CAAC,KAAK;AACR;AAAA,MACF;AACA,UAAI,KAAK,OAAO;AACd,aAAK,UAAU,KAAK,QAAQ,GAAG,IAAI;AAAA,MACrC,OAAO;AACL,aAAK,QAAQ,MAAM,KAAK,YAAY;AACpC,aAAK,OAAO,KAAK,KAAK,KAAK;AAC3B,aAAK,UAAU,KAAK,KAAK,KAAK;AAC9B,aAAK,UAAU,KAAK,QAAQ,GAAG,IAAI;AAAA,MACrC;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,EAGA,gBAAgB,WAAW;AACzB,WAAO,mBAAmB,KAAK,SAAS,EAAE,KAAK,UAAU,WAAS,IAAI,WAAW,cAAY;AAC3F,YAAM,GAAG,WAAW,UAAQ,KAAK,OAAO,IAAI,MAAM,SAAS,KAAK,IAAI,CAAC,CAAC;AACtE,aAAO,MAAM;AACX,YAAI,KAAK,OAAO;AACd,cAAI,CAAC,KAAK,MAAM,WAAW,GAAG;AAC5B,kBAAM,IAAI,SAAS;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC,CAAC,CAAC;AAAA,EACL;AAkEF;AAhEI,qBAAK,YAAO,SAAS,4BAA4B,mBAAmB;AAClE,SAAO,KAAK,qBAAqB,sBAAqB;AACxD;AAGA,qBAAK,YAAsB,gBAAG,4BAAkB;AAAA,EAC9C,MAAM;AAAA,EACN,WAAW,CAAC,CAAC,SAAS,GAAG,CAAC,IAAI,WAAW,EAAE,CAAC;AAAA,EAC5C,QAAQ;AAAA,IACN,SAAS,CAAC,GAAG,SAAS;AAAA,IACtB,OAAO,CAAC,GAAG,OAAO;AAAA,IAClB,UAAU,CAAC,GAAG,UAAU;AAAA,IACxB,OAAO,CAAC,GAAG,OAAO;AAAA,IAClB,YAAY,CAAC,GAAG,YAAY;AAAA,IAC5B,SAAS,CAAC,GAAG,SAAS;AAAA,IACtB,aAAa,CAAC,GAAG,aAAa;AAAA,IAC9B,aAAa,CAAC,GAAG,aAAa;AAAA,EAChC;AAAA,EACA,SAAS;AAAA,IACP,WAAW;AAAA,IACX,cAAc;AAAA,IACd,YAAY;AAAA,IACZ,eAAe;AAAA,IACf,gBAAgB;AAAA,IAChB,gBAAgB;AAAA,IAChB,cAAc;AAAA,IACd,gBAAgB;AAAA,IAChB,eAAe;AAAA,IACf,gBAAgB;AAAA,IAChB,kBAAkB;AAAA,IAClB,gBAAgB;AAAA,IAChB,eAAe;AAAA,IACf,oBAAoB;AAAA,IACpB,0BAA0B;AAAA,IAC1B,qBAAqB;AAAA,IACrB,uBAAuB;AAAA,IACvB,4BAA4B;AAAA,IAC5B,gCAAgC;AAAA,IAChC,mBAAmB;AAAA,IACnB,eAAe;AAAA,IACf,wBAAwB;AAAA,IACxB,gBAAgB;AAAA,IAChB,cAAc;AAAA,IACd,eAAe;AAAA,IACf,sBAAsB;AAAA,IACtB,0BAA0B;AAAA,IAC1B,cAAc;AAAA,IACd,sBAAsB;AAAA,IACtB,uBAAuB;AAAA,IACvB,uBAAuB;AAAA,IACvB,kBAAkB;AAAA,IAClB,oBAAoB;AAAA,IACpB,uBAAuB;AAAA,IACvB,YAAY;AAAA,IACZ,eAAe;AAAA,IACf,oBAAoB;AAAA,IACpB,wBAAwB;AAAA,IACxB,eAAe;AAAA,IACf,eAAe;AAAA,EACjB;AAAA,EACA,UAAU,CAAC,SAAS;AAAA,EACpB,UAAU,CAAI,8BAAoB;AACpC,CAAC;AA/QL,IAAM,sBAAN;AAAA,CAkRC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,qBAAqB,CAAC;AAAA,IAC5F,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,UAAU;AAAA,IACZ,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;AACH,SAAS,mBAAmB,QAAQ;AAClC,SAAO;AAAA,IACL,SAAS;AAAA,IACT,UAAU;AAAA,EACZ;AACF;AACA,IAAM,oBAAN,MAAM,kBAAiB;AAAA,EACrB,OAAO,QAAQ,QAAQ;AACrB,WAAO;AAAA,MACL,UAAU;AAAA,MACV,WAAW,CAAC,mBAAmB,MAAM,CAAC;AAAA,IACxC;AAAA,EACF;AAAA,EACA,OAAO,WAAW;AAChB,WAAO;AAAA,MACL,UAAU;AAAA,IACZ;AAAA,EACF;AAgBF;AAdI,kBAAK,YAAO,SAAS,yBAAyB,mBAAmB;AAC/D,SAAO,KAAK,qBAAqB,mBAAkB;AACrD;AAGA,kBAAK,YAAsB,gBAAG,2BAAiB;AAAA,EAC7C,MAAM;AAAA,EACN,SAAS,CAAC,mBAAmB;AAAA,EAC7B,SAAS,CAAC,mBAAmB;AAC/B,CAAC;AAGD,kBAAK,YAAsB,gBAAG,2BAAiB,CAAC,CAAC;AAzBrD,IAAM,mBAAN;AAAA,CA4BC,MAAM;AACL,GAAC,OAAO,cAAc,eAAe,cAAiB,iBAAkB,kBAAkB,CAAC;AAAA,IACzF,MAAM;AAAA,IACN,MAAM,CAAC;AAAA,MACL,SAAS,CAAC,mBAAmB;AAAA,MAC7B,SAAS,CAAC,mBAAmB;AAAA,IAC/B,CAAC;AAAA,EACH,CAAC,GAAG,MAAM,IAAI;AAChB,GAAG;","names":[],"x_google_ignoreList":[0,1,2]}